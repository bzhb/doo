#!/usr/bin/env python3
# -*- coding: UTF8 -*-

#ifndef DOO_PY
#define DOO_PY

"""doo command
NAME
    doo - utility to run user predefined commands

SYNOPSIS
    doo [OPTIONS] [ID]

DESCRIPTION
    Read command in the .doo file in the local folder and execute the choosen command


COMMAND-LINE AND CONFIG FILES OPTIONS

    --debug
        Debug mode with additional prints

    --config-file=FILE
        Use the specified file instead of .doo

    --global_config_file=FILE
        Use the specified file instead of ~/.config/doo/doo.conf

    -g --no-global-config
        Use only the config in the local folder

    -v --verbose

    -l --loop
        After running a command the program doesn't quit and ask for running a new command, until the user hit q or ^C

    -c --no-colors

    -f --no-confirm
        No confirmation is asked before running the command

    -n --numeric-id
        Add a numeric id to every command without numeric id defined in config files

CONFIG FILES
    .doo format: each command line should be in the format:
        [id[,alternative_ids]:][comment]>command
    with :
        id : a unique identifier used to identify the command to run. Can contain any printable character. 
        alternative_ids: one or more optional ids separated by a comma.
        comment: an optional comment or description on the command
        command: the actual command to run

    if id is omitted, one will be automatically generated (from the line number and random characters).
    If no id is given when running the doo command, the command with identifier "default" is going to be executed

    examples of config:
        0: default command > ls -l
        1, kill the fox > killall firefox
        > ls -a
EXAMPLES
AUTHOR
COPYRIGHT
   Copyright (C) 2016  Fargetton Renan 

   GNU GPLv3 or later

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   To get a copy of the GNU General Public License write to the 
   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
   Boston, MA 02110-1301  USA
"""
import os
import shutil
import sys
import subprocess
import getopt
import random
import string
from os.path import expanduser
# for windows compability :
#from colorama import init
#init()

#TODO:
# * parse command line
# * use --more if there is not enough lines
# * add Warning when there is no options file in the current directory
# * read global config file
# * deal with the situation where there is no space for keys / comment / command
# * deal with terminals that don't support colors (option --no-colors)
# * add numeric keys to every command (option --numeric-id)
# * write numeric keys into .doo files
# * write the modified key to .doo file when there is duplicate keys (option -w ?)
# * verify the program is running with python3


commands = {}
keys_to_id = {}
max_keys_width = 0
max_comment_width = 0
max_command_width = 0
has_default_command = False

class term_mode:
   PURPLE = '\033[95m'
   CYAN = '\033[96m'
   DARKCYAN = '\033[36m'
   BLUE = '\033[94m'
   TITLEBLUE = '\033[0;37;44m'
   GREEN = '\033[92m'
   TITLEGREEN = '\033[0;30;42m'
   TITLE = '\033[0;30;47m'
   YELLOW = '\033[93m'
   TITLEYELLOW = '\033[0;30;43m'
   RED = '\033[91m'
   TITLERED = '\033[0;37;41m'
   TITLE = '\033[0;30;47m'
   BOLD = '\033[1m'
   UNDERLINE = '\033[4m'
   NORMAL = '\033[0m'



# Default options:
local_config_only = False
global_config_file = expanduser('~/.config/doo/doo.conf')
local_config_file ='.doo'
debug = False
loop = False
colors = True
verbose = False
no_confirm = False
add_numeric_key = False

def process_cmdline_options(opts):
    global local_config_only,global_config_file,local_config_file,debug
    for o, a in opts:
        if o in ("-h", "--help"):
            print(__doc__)
            sys.exit(0)
        if o in ("-l", "local-config-only"):
            local_config_only = True
        if o in ("-c", "--config-file"):
            local_config_file = expanduser(a)
        if o in ("-g", "--global-config-file"):
            global_config_file = expanduser(a)
        if o in ("-d", "--debug"):
            debug=True

def process_options(opts):
    global loop, colors, verbose, no_confirm, add_numeric_key
    for o, a in opts:
        if o in ("-o", "--loop"):
            loop=True
        if o in ("-n", "--no-colors"):
            colors=False
        if o in ("-v", "--verbose"):
            verbose=True
        if o in ("-f", "--no-confirm"):
            no_confirm=True
        if o in ("-1", "--numeric-id"):
            add_numeric_key=True

def generate_unique_key(key):
    while keys_to_id.get(key) != None:
        # if key is already used, append a random ascii character to the key
        #key += random.choice(string.ascii_lowercase)
        key += random.choice(string.digits)
    return key

def parse_command_file(filename):
    global commands,max_keys_width,max_comment_width,max_command_width,has_default_command
    with open(filename) as command_file:
        # n is not 0 when an other command file has already been read
        n = len(commands)
        for i,line in enumerate(command_file):
            line = line.strip()
            if line == '':
                if verbose:
                    print('line ',i,' is empty. Ignored.')
            elif line[0] == '#':
                # commented lines get ignored
                if verbose:
                    print('line ',i,' is commented. Ignored.')
            elif line[0] == '-':
                # if line is an option line
                process_options(line)
            else:
                #(key_list,comment,command)= parse(line)
                (keys,separator,rest_of_line) = line.partition(':')
                if not separator:
                    # means the separator ':' is not present in the string
                    rest_of_line = keys
                    # By default we attribute the line number as key for the command
                    keys = str(n+i)
                elif not keys:
                    # means no keys where given (line starts with ':')
                    # By default we attribute the line number (starting at line 0) as key for the command
                    keys = str(n+i)
                # split and remove empty keys
                keys_list = [k for k in keys.split(',') if k.strip() ]
                if debug:
                    print("keys_list:",keys_list)
                keys_width = 0
                has_numeric_key = False
                for j,key in enumerate(keys_list) :
                    key = generate_unique_key( key.strip() )
                    keys_width += len(key) + 1 # the +1 is for the comma between keys
                    keys_list[j] = key
                    keys_to_id[key]= n+i
                    if key.isdecimal():
                        has_numeric_key = True
                    if key == 'default':
                        has_default_command = True
                if add_numeric_key and not has_numeric_key:
                    # add a numeric key, if necessary, as FIRST key
                    keys_list.insert(0,generate_unique_key(str(n+i)))
                if keys_width > 0:
                    keys_width -= 1 # because no comma after last key
                if keys_width > max_keys_width:
                    max_keys_width = keys_width
                (comment,separator,command) = rest_of_line.partition('>')
                if not separator:
                    # If no separator is given, we assume the whole string is just a command
                    command = comment
                    comment = ''
                comment = comment.strip()
                l = len(comment)
                if l > max_comment_width:
                    max_comment_width = l
                command = command.strip()
                l = len(command)
                if l > max_command_width:
                    max_command_width = l
                commands[n+i] = ( keys_list , comment , command )

def adjust_width(s,width):
    #TODO: in case the string is truncated, add '...'
    return s[:width].ljust(width)

def print_command_menu():
    global max_keys_width,max_comment_width,max_command_width
    keys_field_width = 20
    comment_field_width = 40
    command_field_width = 40
    #rows, columns = os.popen('stty size', 'r').read().split()
    term = shutil.get_terminal_size((80, 20))
    term_width = term.columns
    if debug:
        print('Terminal width:',term_width)
        print('Max widths: ', max_keys_width,',',max_comment_width,',',max_command_width)
    if max_keys_width + max_comment_width + max_command_width + 3 < term_width :
        # The array lines fill in the terminal
        if debug:
            print('The table fits into the terminal')
        if max_keys_width < 5:
            keys_field_width = 5
        else:
            keys_field_width = max_keys_width
        comment_field_width = max_comment_width
        command_field_width = max_command_width
    else:
        #TODO though choice here about what to scrap
        if debug:
            print("The table doesn't fit into the terminal")
        keys_field_width = max_keys_width
        comment_field_width = max_comment_width
        command_field_width = max_command_width
        pass
    show_comments = True
    if max_comment_width == 0:
        show_comments = False
        comment_field_width = 0
    print(term_mode.TITLEBLUE+'Id(s)'.ljust(keys_field_width),end=':')
    if show_comments:
        print(term_mode.TITLEGREEN+' Comment'.ljust(comment_field_width),end=' ')
    print(term_mode.TITLE+'> Command'.ljust(command_field_width+2)+term_mode.NORMAL)
    for (keys_list,comment,command) in commands.values() :
        keys_str = ''
        for key in keys_list:
            keys_str += key + ','
        keys_str = keys_str[:-1]
        keys_str = adjust_width(keys_str,keys_field_width)
        comment = adjust_width(comment,comment_field_width)
        command = adjust_width(command,command_field_width)
        print(term_mode.BLUE+term_mode.BOLD + keys_str + ':',end=term_mode.NORMAL)
        if show_comments:
            print(term_mode.GREEN+' ',end=comment)
        print(term_mode.NORMAL+'> '+command)

def execute(choice):
    id = keys_to_id.get(choice)
    if id == None:
        print(term_mode.TITLERED+"id '{}' doesn't exist. Abort.".format(choice)+term_mode.NORMAL)
        return 0
    else:
        (keys_list,comment,command) = commands[id]
        confirmation = input(term_mode.NORMAL + term_mode.YELLOW + 'Run command ? '+ term_mode.NORMAL+'> '  + command +' '+ term_mode.TITLEYELLOW  + '[Y/n]' + term_mode.NORMAL)
        if confirmation:
            if confirmation[0] in 'nN':
                if verbose:
                    print('Abort')
            else:
                subprocess.run([command],shell=True)
        else:
            subprocess.run([command],shell=True)
    return 1

def choose_command():
    global has_default_command
    choice = input(term_mode.YELLOW + 'Enter id :'+ term_mode.NORMAL+' '+ term_mode.BLUE+ term_mode.BOLD).strip()
    if not choice:
        if has_default_command:
            choice='default'
        else:
            if verbose:
                print('No choice made.')
    if choice:
        if verbose:
            print(term_mode.NORMAL + 'Choice is : ',choice)
        execute(choice)

def main(argv=None):
    if argv is None:
        argv = sys.argv
    # etc., replacing sys.argv with argv in the getopt() call.
    if debug:
        print("argv: ",argv)
    # parse command line options
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hlc:g:donvf1", ["help","local-config-only","config-file=","global-config-file=","debug","loop","no-colors","verbose","no-confirm","numeric-id"])
    except getopt.GetoptError as err:
        # print help information and exit:
        print(err) # will print something like "option -a not recognized"
        print("for help use --help")
        sys.exit(2)

    # process cmdline-only options
    process_cmdline_options(opts)
    if debug:
        print("opts: ",opts)
        print("args: ",args)

    # process arguments
    key =''
    for w in args:
        key += str(w) + ' '
    key = key.strip()
    if debug:
        print("cmdline key: '" + key + "'")

    # read global config file
    if not local_config_only:
        if debug:
            print("Using global config file: ",global_config_file)
        try:
            parse_command_file(global_config_file)
        except FileNotFoundError:
            print(term_mode.TITLEYELLOW + "Warning: no global config file '{}'".format(global_config_file)+term_mode.NORMAL )
            #TODO propose to create one from template

    # read local config file
    try:
        parse_command_file(local_config_file)
    except FileNotFoundError:
        print(term_mode.TITLEYELLOW + "Warning: no '{}' file in the current directory".format(local_config_file)+term_mode.NORMAL )

    # process the rest of command lines options
    process_options(opts)

    if debug:
        print('###### keys_to_id :')
        print(keys_to_id)
        print('###### commands :')
        print(commands)
        print('###### END (commands)')

    try:
        if key:
            # the key was given in the command line
            key_exists = execute(key)
            if not key_exists:
                ans = input(term_mode.YELLOW + 'Show options ? '+ term_mode.NORMAL+' '+ term_mode.TITLEYELLOW  + '[Y/n]' + term_mode.NORMAL)
                if ans and (ans[0] in 'nN'):
                     if verbose:
                        print('Exit')
                     sys.exit(0) # or 1, or whatever
            else:
               sys.exit(0) # or 1, or whatever

        print_command_menu()
        choose_command()
        while loop:
            ans = input(term_mode.YELLOW + 'Continue ? '+ term_mode.NORMAL+' '+ term_mode.TITLEYELLOW  + '[Y/n]' + term_mode.NORMAL)
            if ans and (ans[0] in 'nN'):
                 if verbose:
                    print('Exit')
                 sys.exit(0) # or 1, or whatever
            else:
                print_command_menu()
                choose_command()
    except KeyboardInterrupt:
        sys.exit(0) # or 1, or whatever

if __name__ == "__main__":
    sys.exit(main())
#endif // DO_PY
