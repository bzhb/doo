#!/usr/bin/env python3
# -*- coding: UTF8 -*-

#ifndef DOO_PY
#define DOO_PY

"""doo command
NAME
    doo - utility to run user predefined commands

SYNOPSIS
    doo [OPTIONS] [COMMAND ID]

DESCRIPTION
    Console utility to execute user-defined command fron a .doo file in the local folder.

COMMAND ID
    Command identifier in the command file (.doo).

COMMAND-LINE ONLY OPTIONS

    -h --help
        Show help

    -i --file=FILE
        Use the specified configuration file from local directory instead of .doo

    -g --global-file=FILENAME
        Use the file ~/.config/doo/FILENAME.doo instead of local .doo file
        If no FILENAME is specified, reading ~/.config/doo/default.doo

    -d --debug
        Debug mode with additional prints


COMMAND-LINE AND CONFIG FILES OPTIONS

    -f --no-confirm
        No confirmation is asked before running the command

    -F --force-confirm
        User is asked confirmation before running the command. This is the default behavior, this option is only necessary to superseed options set in a config file

    -o --loop
        After running a command the program doesn't quit and ask for running a new command, until the user hit q or ^C

    -v --verbose

    -c --no-colors
        disable colors

    -C --force-colors
        This is the default behavior, this option is only necessary to superseed options set in a config file

    -w --write-ids
        Add a numeric id to every command without numeric id defined in config files
    -s --standardize (NOT IMPLEMENTED)
        edit the command file to put it the standard format (add missing delemiters and spaces to align text), put an intro for options, current .doo file is moved to .doo.old

LOCAL COMMAND FILE
    The command file in the local directory should be named .doo (or otherwise its name shoud be given with --file option).

    .doo format: each command line should be in the format:
        [id[,alternative_ids]:][comment]>command

    with :
        id             : a unique identifier used to identify the command to run.
        alternative_ids: one or more optional ids separated by a comma.
        comment        : an optional comment or description on the command
        command        : the actual command to run

    If id is omitted, one will be automatically generated (from the line number and random characters).
    If no id is given when running the doo command, the command with identifier "default" is going to be executed

    examples of config in .doo file:
        0,default: default command > ls -l
        1, kill the fox > killall firefox
        > ls -a

GLOBAL CONFIG FILES
    Global config files are in the ~/.config/doo/ repository

    doo.conf : this file is always parsed when doo command is used. This the designated location to define user default options. Although it is not recommended, it is possible to insert command lines in this file. In this case thoose commands will appear in the table everytime doo is run.

    FILENAME.doo : It is possible (and encouraged) to create or modify other global command files like FILENAME.doo to be used with the -g options, like : doo -g FILENAME.

EXAMPLES
    doo
    doo COMMAND_KEY
    doo -g system reboot (use ~/.config/doo/system.doo)

AUTHOR
    Fargetton Renan <renan.fargetton <at> .com > 2016

COPYRIGHT
   Copyright (C) 2016-2017  Fargetton Renan 

   GNU GPLv3 or later

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   To get a copy of the GNU General Public License write to the 
   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
   Boston, MA 02110-1301  USA
"""
import os
import shutil
from shutil import copyfile
import sys
import subprocess
import getopt
import random
import string
import termios, tty
from os.path import expanduser
# for windows compability :
#from colorama import init
#init()

#TODO:
# * add numeric keys to every command (force what previously was option --numeric-id)
# * Implement all the changes for options described in --help
# * parse command line
# * write the modified key to .doo file when there is duplicate keys (option -w ?)
# * verify the program is running with python3
# * predictable ids : always generate the same unique_key : hash functions ? Or force -w option ?
# * reorganise code in several files + separate package build
# * propose to edit command/config file when created
# * make better template and default conf file

class data:
    commands = {}
    keys_to_id = {}
class global_vars:
    max_keys_width = 0
    max_comment_width = 0
    max_command_width = 0

class options:
    # Default options:
    debug = False
    loop = False
    colors = True
    verbose = False
    no_confirm = False
    add_numeric_key = False
    has_default_command = False

    no_system_install=False
    if no_system_install:
        # Options for testing in devel directory:
        global_config_file_template = 'usr_share/doo.conf'
        command_file_template = 'usr_share/template.doo'
        global_config_dir = expanduser('config/')
    else:
        # The files location in production:
        global_config_file_template = '/usr/share/doo/doo.conf'
        command_file_template = '/usr/share/doo/template.doo'
        global_config_dir = expanduser('~/.config/doo/')
    global_config_file = global_config_dir + 'doo.conf'
    global_command_file = global_config_dir + 'default.doo'
    local_command_file = '.doo'

class term_mode:
   PURPLE      = '\033[95m'
   CYAN        = '\033[96m'
   DARKCYAN    = '\033[36m'
   BLUE        = '\033[94m'
   TITLEBLUE   = '\033[0;37;44m'
   GREEN       = '\033[92m'
   TITLEGREEN  = '\033[0;30;42m'
   TITLE       = '\033[0;30;47m'
   YELLOW      = '\033[93m'
   TITLEYELLOW = '\033[0;30;43m'
   RED         = '\033[91m'
   TITLERED    = '\033[0;37;41m'
   TITLE       = '\033[0;30;47m'
   BOLD        = '\033[1m'
   UNDERLINE   = '\033[4m'
   NORMAL      = '\033[0m'

def remove_colors_and_bold():
   term_mode.PURPLE      = ''
   term_mode.CYAN        = ''
   term_mode.DARKCYAN    = ''
   term_mode.BLUE        = ''
   term_mode.TITLEBLUE   = ''
   term_mode.GREEN       = ''
   term_mode.TITLEGREEN  = ''
   term_mode.TITLE       = ''
   term_mode.YELLOW      = ''
   term_mode.TITLEYELLOW = ''
   term_mode.RED         = ''
   term_mode.TITLERED    = ''
   term_mode.TITLE       = ''
   term_mode.BOLD        = ''
   term_mode.UNDERLINE   = ''
   term_mode.NORMAL      = ''

def process_cmdline_only_options(opts):
    use_a_global_command_file = False
    for o, a in opts:
        if o in ("-h", "--help"):
            print(__doc__)
            sys.exit(0)
        if o in ("-i", "--file"):
            options.local_command_file = expanduser(a)
        if o in ("-g", "--global-file"):
            options.global_command_file = options.global_config_dir + expanduser(a) + ".doo"
            if options.debug :
                print("global command file a=" + a)
            #TODO deal with empty "a" : "doo -g " should use default.doo or ask
            use_a_global_command_file = True
        if o in ("-d", "--debug"):
            options.debug=True
        #nb: add_numeric_key is not a commandline-only option but it must be processed early nontheless
        if o in ("-w", "--numeric-id"):
            options.add_numeric_key=True
    return use_a_global_command_file

def process_options(opts):
    if options.debug:
        print("Process options: "+ str(opts))
    for o, a in opts:
        if o in ("-f", "--no-confirm"):
            options.no_confirm=True
        if o in ("-F", "--force-confirm"):
            options.no_confirm=False
        if o in ("-v", "--verbose"):
            options.verbose=True
        if o in ("-o", "--loop"):
            options.loop=True
        if o in ("-c", "--no-colors"):
            options.colors=False
        if o in ("-C", "--force-colors"):
            options.colors=True
        if o in ("-w", "--numeric-id"):
            options.add_numeric_key=True

def generate_unique_key(key):
    while data.keys_to_id.get(key) != None:
        # if key is already used, append a random ascii character to the key
        #key += random.choice(string.ascii_lowercase)
        key += random.choice(string.digits)
    return key

def sort_options_and_arguments(line):
    try:
        return getopt.getopt(line, "hi:g:dfFovcCws", ["help","file=","global-file=","debug","no-confirm","force-confirm","loop","verbose","no-colors","force-colors""write-ids","standardize"])
    except getopt.GetoptError as err:
        # print help information and exit:
        print(err) # will print something like "option -a not recognized"
        print("for help use --help")
        sys.exit(2)

def parse_command_file(filename):
    with open(filename) as command_file:
        # n is not 0 when an other command file has already been read
        n = len(data.commands)
        for i,line in enumerate(command_file):
            line = line.strip()
            if line == '':
                if options.verbose:
                    print('line ',i,' is empty. Ignored.')
            elif line[0] == '#':
                # commented lines get ignored
                if options.verbose:
                    print('line ',i,' is commented. Ignored.')
            elif line[0] == '-':
                # this line is an option line
                if options.debug:
                    print("Option line is: "+line)
                (opts, args) = sort_options_and_arguments(line.split())
                if options.debug:
                    print("opts: ",opts)
                    print("args: ",args)
                process_options(opts)
            else:
                #(key_list,comment,command)= parse(line)
                (keys,separator,rest_of_line) = line.partition(':')
                if not separator:
                    # means the separator ':' is not present in the string
                    rest_of_line = keys
                    # By default we attribute the line number as key for the command
                    keys = str(n+i)
                elif not keys:
                    # means no keys where given (line starts with ':')
                    # By default we attribute the line number (starting at line 0) as key for the command
                    keys = str(n+i)
                # split and remove empty keys
                keys_list = [k for k in keys.split(',') if k.strip() ]
                if options.debug:
                    print("keys_list:",keys_list)
                keys_width = 0
                has_numeric_key = False
                for j,key in enumerate(keys_list) :
                    key = generate_unique_key( key.strip() )
                    keys_width += len(key) + 1 # the +1 is for the comma between keys
                    keys_list[j] = key
                    data.keys_to_id[key]= n+i
                    if key.isdecimal():
                        has_numeric_key = True
                    if key == 'default':
                        #nb: if several commands have the default key, only the first one will not be modified by generate_unique_keys, so no need to worry about multiple command with default flag
                        options.has_default_command = True
                if options.add_numeric_key and not has_numeric_key:
                    # add a numeric key, if necessary, as FIRST key
                    key = generate_unique_key(str(n+i))
                    keys_width += len(key) + 1 # the +1 is for the comma between keys
                    keys_list.insert(0,key)
                    data.keys_to_id[key]= n+i
                    has_numeric_key = True
                if keys_width > 0:
                    keys_width -= 1 # because no comma after last key
                if keys_width > global_vars.max_keys_width:
                    global_vars.max_keys_width = keys_width
                (comment,separator,command) = rest_of_line.partition('>')
                if not separator:
                    # If no separator is given, we assume the whole string is just a command
                    command = comment
                    comment = ''
                comment = comment.strip()
                l = len(comment)
                if l > global_vars.max_comment_width:
                    global_vars.max_comment_width = l
                command = command.strip()
                l = len(command)
                if l > global_vars.max_command_width:
                    global_vars.max_command_width = l
                data.commands[n+i] = ( keys_list , comment , command )

def check_then_parse_file(filename,str_filetype,template):
    if options.debug:
        print("Using ",str_filetype," file: ", filename)
    try:
        parse_command_file(filename)
    except FileNotFoundError:
        print(term_mode.TITLEYELLOW + "Warning: no {} file '{}'".format(str_filetype,filename)+term_mode.NORMAL )
        ans = input(term_mode.YELLOW + "Do you want to create one from template ?"+ term_mode.TITLEYELLOW  + '[Y/n]'+term_mode.NORMAL )
        if ans and (ans[0] in 'nN'):
             if options.verbose:
                print("No ",str_filetype," file created")
        else:
             if options.verbose:
                print("Creating ",str_filetype," file...")
             #TODO more security checks
             os.makedirs(options.global_config_dir, exist_ok=True)
             copyfile( template , filename )
             if options.verbose:
                print("Done")
             parse_command_file(filename)

def adjust_width(s,width):
    if len(s) > width:
        # string needs to be truncated
        if width >= 1:
            return (s[:(width-1)]+'…').ljust(width)
        else:
            # given width is 0 (or negative) return empty string
            return ""
    else:
        return s.ljust(width)

def print_command_menu():
    show_comments = True
    show_commands = True
    #rows, columns = os.popen('stty size', 'r').read().split()
    term = shutil.get_terminal_size((80, 20))
    term_width = term.columns
    term_height = term.lines

    # We assign the optimal width for each field
    if global_vars.max_keys_width < 6:
        keys_field_width = 6 # len("Id(s):")
    else:
        keys_field_width = global_vars.max_keys_width +1 # +1 is for ':'
    if global_vars.max_comment_width == 0:
        comment_field_width = 0 # comment column is not gowing to be displayed
        show_comments = False
    elif global_vars.max_comment_width < 9:
        comment_field_width = 9 # len(" Comment ")
    else:
        comment_field_width = global_vars.max_comment_width +2 # +2 is for space at beginning and end of comment
    if global_vars.max_command_width < 8:
        command_field_width = 9 # len("> Command")
    else:
        command_field_width = global_vars.max_command_width + 2 # +2 is for '> ' at beginning of command

    if options.debug:
        print('Terminal width:',term_width)
        print('Max widths: ', global_vars.max_keys_width,',',global_vars.max_comment_width,',',global_vars.max_command_width)
        print('Fields width: ', keys_field_width,',',comment_field_width,',',command_field_width)

    if  keys_field_width + comment_field_width + command_field_width <= term_width :
        # The table colums fits into the terminal
        if options.debug:
            print('The table fits into the terminal')
    else:
        # though choice here about what to scrap
        if options.debug:
            print("The table doesn't fit into the terminal")
        if keys_field_width <= term_width :
            # we dispay all the keys (it fits)
            remaining_width = term_width - keys_field_width
            if comment_field_width == 0:
                # no comments.
                command_field_width = remaining_width
            else:
                # split the remaing space 30%/70% between comment/command
                comment_field_width = min( comment_field_width , remaining_width*3//10 )
                if comment_field_width < 9:
                    # Not useful to display the comment if column is too small
                    comment_field_width = 0
                    show_comments = False
                remaining_width = remaining_width - comment_field_width
                if command_field_width > remaining_width:
                    command_field_width = remaining_width
                else :
                    # in this case the command_field does not take all of assigned 70%, the remaining space can be used by the comment field
                    comment_field_width = term_width - keys_field_width - command_field_width
                    show_comments = True
                    if comment_field_width < 9:
                        # Not useful to display the comment if column is too small
                        comment_field_width = 0
                        show_comments = False
        else:
            # it is needed to cut into the keys field / comments and commands not displayed
            keys_field_width = term_width
            comment_field_width = 0
            command_field_width = 0
            show_commands = False
            show_comments = False
    if global_vars.max_comment_width == 0:
        show_comments = False
        comment_field_width = 0

    print(term_mode.TITLEBLUE+adjust_width('Id(s)',keys_field_width-1),end=':')
    if show_comments:
        print(term_mode.TITLEGREEN+adjust_width(' Comment ',comment_field_width),end='')
    if show_commands:
        print(term_mode.TITLE+adjust_width('> Command',command_field_width)+term_mode.NORMAL)
    else:
        # return to next line and normal mode
        print(term_mode.NORMAL)
    printed_lines = 1
    for (keys_list,comment,command) in data.commands.values() :
        if printed_lines == term_height-1 :
            # wait for more
            stdinFileDesc = sys.stdin.fileno() #store stdin's file descriptor
            oldStdinTtyAttr = termios.tcgetattr(stdinFileDesc) #save stdin's tty attributes so I can reset it later

            try:
                print(term_mode.TITLEBLUE + "-- More --" + term_mode.NORMAL,end="\r")
                os.system('setterm -cursor off')
                tty.setraw(stdinFileDesc) #set the input mode of stdin so that it gets added to char by char rather than line by line
                char = sys.stdin.read(1) #read 1 byte from stdin (indicating that a key has been pressed)
                if char == "q":
                     if options.verbose:
                        print('Exit')
                     sys.exit(0) # or 1, or whatever
            finally:
                termios.tcsetattr(stdinFileDesc, termios.TCSADRAIN, oldStdinTtyAttr) #reset stdin to its normal behavior
                os.system('setterm -cursor on')
                #print("\r") # bring back the cursor at the beginning of the line (to remove "-- More --")

            printed_lines = 0
        keys_str = ''
        for key in keys_list:
            keys_str += key + ','
        keys_str = keys_str[:-1]
        keys_str = adjust_width(keys_str,keys_field_width -1)
        print(term_mode.BLUE+term_mode.BOLD + keys_str + ':',end=term_mode.NORMAL)
        if show_comments:
            comment = adjust_width(comment,comment_field_width -2)
            print(term_mode.GREEN+' '+comment,end=' ')
        if show_commands:
            command = adjust_width(command,command_field_width -2)
            print(term_mode.NORMAL+'> '+command)
        else:
            # return to next line
            print(term_mode.NORMAL)
        printed_lines += 1

def execute(choice):
    id = data.keys_to_id.get(choice)
    if id == None:
        print(term_mode.TITLERED+"id '{}' doesn't exist. Abort.".format(choice)+term_mode.NORMAL)
        return 0
    else:
        (keys_list,comment,command) = data.commands[id]
        if options.no_confirm:
            if options.verbose:
                print(term_mode.NORMAL + term_mode.YELLOW + 'Running command: '+ term_mode.NORMAL+'> '  + command + term_mode.NORMAL)
            subprocess.run([command],shell=True)
        else:
            confirmation = input(term_mode.NORMAL + term_mode.YELLOW + 'Run command ? '+ term_mode.NORMAL+'> '  + command +' '+ term_mode.TITLEYELLOW  + '[Y/n]' + term_mode.NORMAL)
            if confirmation:
                if confirmation[0] in 'nN':
                    if options.verbose:
                        print('Abort')
                else:
                    subprocess.run([command],shell=True)
            else:
                subprocess.run([command],shell=True)
    return 1

def choose_command():
    choice = input(term_mode.YELLOW + 'Enter id [or (q)uit] :'+ term_mode.NORMAL+' '+ term_mode.BLUE+ term_mode.BOLD).strip()
    print(term_mode.NORMAL)
    if not choice:
        if options.has_default_command:
            choice='default'
        else:
            if options.verbose:
                print('No choice made.')
    if choice:
        if options.verbose:
            print(term_mode.NORMAL + 'Choice is : ',choice)
        if choice in ["quit","q","exit"]:
            sys.exit(0) # or 1, or whatever
        else:
            execute(choice)
    else:
        # No choice made and no default command, so doing nothing
        if options.verbose:
            print('No command to execute.')
        pass

def main(argv=None):
    if argv is None:
        argv = sys.argv
    # etc., replacing sys.argv with argv in the getopt() call.
    (opts, args) = sort_options_and_arguments(sys.argv[1:])

    # process cmdline-only options (needs to be early for debug flag)
    use_a_global_command_file = process_cmdline_only_options(opts)

    if options.debug:
        print("argv: ",argv)
        print("opts: ",opts)
        print("args: ",args)

    # process arguments into a string
    key =''
    for w in args:
        key += str(w) + ' '
    key = key.strip()
    if options.debug:
        print("cmdline key: '" + key + "'")

    # read global config file
    check_then_parse_file(options.global_config_file,"global config",options.global_config_file_template)

    # read choosen command file
    if options.debug:
        print("Using global commands ? : " + str(use_a_global_command_file) )
    if use_a_global_command_file:
        # read global command file
        check_then_parse_file(options.global_command_file,"global command",options.command_file_template)
    else:
        # read local command file
        check_then_parse_file(options.local_command_file,"command",options.command_file_template)

    # process the rest of command lines options
    # nb : command lines options must be processed after command file is read because it can overwrite options
    process_options(opts)

    if not options.colors:
        remove_colors_and_bold()

    if options.debug:
        print('###### data.keys_to_id :')
        print(data.keys_to_id)
        print('###### data.commands :')
        print(data.commands)
        print('###### END (data.commands)')

    try:
        if key:
            # the key was given in the command line
            key_exists = execute(key)
            if not key_exists:
                ans = input(term_mode.YELLOW + 'Show options ? '+ term_mode.NORMAL+' '+ term_mode.TITLEYELLOW  + '[Y/n]' + term_mode.NORMAL)
                if ans and (ans[0] in 'nN'):
                     if options.verbose:
                        print('Exit')
                     sys.exit(0) # or 1, or whatever
            else:
               sys.exit(0) # or 1, or whatever

        print_command_menu()
        choose_command()
        while options.loop:
            ans = input(term_mode.YELLOW + 'Continue ? '+ term_mode.NORMAL+' '+ term_mode.TITLEYELLOW  + '[Y/n]' + term_mode.NORMAL)
            if ans and (ans[0] in 'nN'):
                 if options.verbose:
                    print('Exit')
                 sys.exit(0) # or 1, or whatever
            else:
                print_command_menu()
                choose_command()
    except KeyboardInterrupt:
        sys.exit(0) # or 1, or whatever

if __name__ == "__main__":
    sys.exit(main())
#endif // DO_PY
