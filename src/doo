#!/usr/bin/env python3
# -*- coding: UTF8 -*-

#ifndef DOO_PY
#define DOO_PY

"""doo command
NAME
    doo - utility to run user predefined commands

SYNOPSIS
    doo [OPTIONS] [COMMAND ID]

DESCRIPTION
    Console utility to execute user-defined command fron a .doo file in the local folder.

COMMAND ID
    Command identifier in the command file (.doo).

COMMAND-LINE ONLY OPTIONS

    -h --help
        Show help

    -i --file=FILE
        Use the specified configuration file from local directory instead of .doo

    -g --global-file=FILENAME
        Use the file ~/.config/doo/FILENAME.doo instead of local .doo file
        If no FILENAME is specified, reading ~/.config/doo/default.doo

    -d --debug
        Debug mode with additional prints


COMMAND-LINE AND CONFIG FILES OPTIONS

    -f --no-confirm
        No confirmation is asked before running the command

    -F --force-confirm
        User is asked confirmation before running the command. This is the default behavior, this option is only necessary to superseed options set in a config file

    -o --loop
        After running a command the program doesn't quit and ask for running a new command, until the user hit q or ^C

    -v --verbose

    -c --no-colors
        disable colors

    -C --force-colors
        This is the default behavior, this option is only necessary to superseed options set in a config file

    -w --write-ids
        Add a numeric id to every command without numeric id defined in config files
    -s --standardize (NOT IMPLEMENTED)
        edit the command file to put it the standard format (add missing delemiters and spaces to align text)

LOCAL COMMAND FILE
    The command file in the local directory should be named .doo (or otherwise it is needed to use --file option).

    .doo format: each command line should be in the format:
        [id[,alternative_ids]:][comment]>command
    
    with :
        id             : a unique identifier used to identify the command to run.
        alternative_ids: one or more optional ids separated by a comma.
        comment        : an optional comment or description on the command
        command        : the actual command to run

    If id is omitted, one will be automatically generated (from the line number and random characters).
    If no id is given when running the doo command, the command with identifier "default" is going to be executed

    examples of config in .doo file:
        0: default command > ls -l
        1, kill the fox > killall firefox
        > ls -a

GLOBAL CONFIG FILES
    Global config files are in the ~/.config/doo/ repository

    doo.conf : this file is always parsed when doo command is used. This the designated location to define user default options. Although it is not recommended, it is possible to insert command lines in this file. In this case thoose commands will appear in the table everytime doo is run.

    FILENAME.doo : It is possible (and encouraged) to create or modify other global command files like FILENAME.doo to be used with the -g options, like : doo -g FILENAME.

EXAMPLES
    doo
    doo COMMAND_KEY
    doo -g system reboot (use ~/.config/doo/system.doo)

AUTHOR
    Fargetton Renan <renan.fargetton <at> .com > 2016

COPYRIGHT
   Copyright (C) 2016-2017  Fargetton Renan 

   GNU GPLv3 or later

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   To get a copy of the GNU General Public License write to the 
   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
   Boston, MA 02110-1301  USA
"""
import os
import shutil
from shutil import copyfile
import sys
import subprocess
import getopt
import random
import string
from os.path import expanduser
# for windows compability :
#from colorama import init
#init()

#TODO:
# * add option to write numeric keys into .doo files
# * add numeric keys to every command (force what previously was option --numeric-id)
# * Implement all the changes for options described in --help
# * parse command line
# * use --more if there is not enough lines
# * deal with the situation where there is no space for keys / comment / command
# * deal with terminals that don't support colors (option --no-colors)
# * write the modified key to .doo file when there is duplicate keys (option -w ?)
# * verify the program is running with python3
# * deal with potential problems when several "default are inserted", especially from different files."
# * predictable ids : always generate the same unique_key : hash functions ? Or force -w option ?
# * reorganise code in several files + separate package build
# * propose to edit command/config file when created
# * 

commands = {}
keys_to_id = {}
max_keys_width = 0
max_comment_width = 0
max_command_width = 0
has_default_command = False

class term_mode:
   PURPLE = '\033[95m'
   CYAN = '\033[96m'
   DARKCYAN = '\033[36m'
   BLUE = '\033[94m'
   TITLEBLUE = '\033[0;37;44m'
   GREEN = '\033[92m'
   TITLEGREEN = '\033[0;30;42m'
   TITLE = '\033[0;30;47m'
   YELLOW = '\033[93m'
   TITLEYELLOW = '\033[0;30;43m'
   RED = '\033[91m'
   TITLERED = '\033[0;37;41m'
   TITLE = '\033[0;30;47m'
   BOLD = '\033[1m'
   UNDERLINE = '\033[4m'
   NORMAL = '\033[0m'


no_system_install=False
# Options for testing:
if no_system_install:
    global_config_file_template = 'usr_share/doo.conf'
    command_file_template = 'usr_share/template.doo'
    global_config_dir = expanduser('config/')
else:
    global_config_file_template = '/usr/share/doo/doo.conf'
    command_file_template = '/usr/share/doo/template.doo'
    global_config_dir = expanduser('~/.config/doo/')
global_config_file = global_config_dir + 'doo.conf'
global_command_file = global_config_dir + 'default.doo'
local_command_file = '.doo'

# Default options:
debug = False
loop = False
colors = True
verbose = False
no_confirm = False
add_numeric_key = False

def process_cmdline_only_options(opts):
    global global_command_file,local_command_file,debug
    use_a_global_command_file = False
    for o, a in opts:
        if o in ("-h", "--help"):
            print(__doc__)
            sys.exit(0)
        if o in ("-i", "--file"):
            local_command_file = expanduser(a)
        if o in ("-g", "--global-file"):
            global_command_file = global_config_dir + expanduser(a) + ".doo"
            if debug :
                print("global command file a=" + a)
            #TODO deal with empty "a" : "doo -g " should use default.doo or ask
            use_a_global_command_file = True
        if o in ("-d", "--debug"):
            debug=True
    return use_a_global_command_file

def process_options(opts):
    global loop, colors, verbose, no_confirm, add_numeric_key
    if debug:
        print("Process options: "+ str(opts))
    for o, a in opts:
        if o in ("-f", "--no-confirm"):
            no_confirm=True
        if o in ("-F", "--force-confirm"):
            no_confirm=False
        if o in ("-v", "--verbose"):
            verbose=True
        if o in ("-o", "--loop"):
            loop=True
        if o in ("-c", "--no-colors"):
            colors=False
        if o in ("-C", "--force-colors"):
            colors=True
        if o in ("-w", "--numeric-id"):
            add_numeric_key=True

def generate_unique_key(key):
    while keys_to_id.get(key) != None:
        # if key is already used, append a random ascii character to the key
        #key += random.choice(string.ascii_lowercase)
        key += random.choice(string.digits)
    return key

def parse_command_file(filename):
    global commands,max_keys_width,max_comment_width,max_command_width,has_default_command
    with open(filename) as command_file:
        # n is not 0 when an other command file has already been read
        n = len(commands)
        for i,line in enumerate(command_file):
            line = line.strip()
            if line == '':
                if verbose:
                    print('line ',i,' is empty. Ignored.')
            elif line[0] == '#':
                # commented lines get ignored
                if verbose:
                    print('line ',i,' is commented. Ignored.')
            elif line[0] == '-':
                # this line is an option line
                if debug:
                    print("Option line is: "+line)
                try:
                    (opts , args) = getopt.getopt(line.split(), "hi:g:dfFovcCws", ["help","file=","global-file=","debug","no-confirm","force-confirm","loop","verbose","no-colors","force-colors""write-ids","standardize"])
                except getopt.GetoptError as err:
                    # print help information and exit:
                    print("In config file'"+filename+"': "+err) # will print something like "option -a not recognized"
                    print("for help use --help")
                    sys.exit(2)
                if debug:
                    print("opts: ",opts)
                    print("args: ",args)
                process_options(opts)
            else:
                #(key_list,comment,command)= parse(line)
                (keys,separator,rest_of_line) = line.partition(':')
                if not separator:
                    # means the separator ':' is not present in the string
                    rest_of_line = keys
                    # By default we attribute the line number as key for the command
                    keys = str(n+i)
                elif not keys:
                    # means no keys where given (line starts with ':')
                    # By default we attribute the line number (starting at line 0) as key for the command
                    keys = str(n+i)
                # split and remove empty keys
                keys_list = [k for k in keys.split(',') if k.strip() ]
                if debug:
                    print("keys_list:",keys_list)
                keys_width = 0
                has_numeric_key = False
                for j,key in enumerate(keys_list) :
                    key = generate_unique_key( key.strip() )
                    keys_width += len(key) + 1 # the +1 is for the comma between keys
                    keys_list[j] = key
                    keys_to_id[key]= n+i
                    if key.isdecimal():
                        has_numeric_key = True
                    if key == 'default':
                        has_default_command = True
                if add_numeric_key and not has_numeric_key:
                    # add a numeric key, if necessary, as FIRST key
                    keys_list.insert(0,generate_unique_key(str(n+i)))
                if keys_width > 0:
                    keys_width -= 1 # because no comma after last key
                if keys_width > max_keys_width:
                    max_keys_width = keys_width
                (comment,separator,command) = rest_of_line.partition('>')
                if not separator:
                    # If no separator is given, we assume the whole string is just a command
                    command = comment
                    comment = ''
                comment = comment.strip()
                l = len(comment)
                if l > max_comment_width:
                    max_comment_width = l
                command = command.strip()
                l = len(command)
                if l > max_command_width:
                    max_command_width = l
                commands[n+i] = ( keys_list , comment , command )

def check_then_parse_file(filename,str_filetype,template):
    if debug:
        print("Using ",str_filetype," file: ", filename)
    try:
        parse_command_file(filename)
    except FileNotFoundError:
        print(term_mode.TITLEYELLOW + "Warning: no {} file '{}'".format(str_filetype,filename)+term_mode.NORMAL )
        ans = input(term_mode.YELLOW + "Do you want to create one from template ?"+ term_mode.TITLEYELLOW  + '[Y/n]'+term_mode.NORMAL )
        if ans and (ans[0] in 'nN'):
             if verbose:
                print("No ",str_filetype," file created")
        else:
             if verbose:
                print("Creating ",str_filetype," file...")
             #TODO more security checks
             os.makedirs(global_config_dir, exist_ok=True)
             copyfile( template , filename )
             if verbose:
                print("Done")
             parse_command_file(filename)

def adjust_width(s,width):
    if len(s) > width:
        # string needs to be truncated
        if width >= 1:
            return (s[:(width-1)]+'…').ljust(width)
        else:
            # given width is 0 (or negative) return empty string
            return ""
    else:
        return s.ljust(width)

def print_command_menu():
    global max_keys_width,max_comment_width,max_command_width
    show_comments = True
    show_commands = True
    keys_field_width = 20
    comment_field_width = 40
    command_field_width = 40
    #rows, columns = os.popen('stty size', 'r').read().split()
    term = shutil.get_terminal_size((80, 20))
    term_width = term.columns
    if debug:
        print('Terminal width:',term_width)
        print('Max widths: ', max_keys_width,',',max_comment_width,',',max_command_width)
    if max_keys_width + max_comment_width + max_command_width + 3 < term_width :
        # The array lines fill in the terminal
        if debug:
            print('The table fits into the terminal')
        if max_keys_width < 5:
            keys_field_width = 5
        else:
            keys_field_width = max_keys_width
        comment_field_width = max_comment_width
        command_field_width = max_command_width
    else:
        #TODO though choice here about what to scrap
        if debug:
            print("The table doesn't fit into the terminal")
        if max_keys_width + 3 < term_width :
            # we dispay all the keys (it fits)
            keys_field_width = max_keys_width
            remaining_width = term_width - (max_keys_width + 3)
            if max_comment_width == 0:
                # no comments.
                comment_field_width = max_comment_width
                command_field_width = remaining_width
            else:
                # split the remaing space 30%/70%
                comment_field_width = min(max_keys_width,remaining_width*3//10 -1 )
                command_field_width = min(max_command_width,remaining_width - comment_field_width -3)
        else:
            # it is needed to scrap the keys
            keys_field_width = term_width-1
            comment_field_width = 0
            command_field_width = 0
            show_commands = False
            show_comments = False
    if max_comment_width == 0:
        show_comments = False
        comment_field_width = 0
    print(term_mode.TITLEBLUE+'Id(s)'.ljust(keys_field_width),end=':')
    if show_comments:
        print(term_mode.TITLEGREEN+' Comment'.ljust(comment_field_width),end=' ')
    if show_commands:
        print(term_mode.TITLE+'> Command'.ljust(command_field_width+2)+term_mode.NORMAL)
    else:
        # return to next line and normal mode
        print(term_mode.NORMAL)
    for (keys_list,comment,command) in commands.values() :
        keys_str = ''
        for key in keys_list:
            keys_str += key + ','
        keys_str = keys_str[:-1]
        keys_str = adjust_width(keys_str,keys_field_width)
        comment = adjust_width(comment,comment_field_width)
        command = adjust_width(command,command_field_width)
        print(term_mode.BLUE+term_mode.BOLD + keys_str + ':',end=term_mode.NORMAL)
        if show_comments:
            print(term_mode.GREEN+' ',end=comment)
        if show_commands:
            print(term_mode.NORMAL+'> '+command)
        else:
            # return to next line
            print('')

def execute(choice):
    id = keys_to_id.get(choice)
    if id == None:
        print(term_mode.TITLERED+"id '{}' doesn't exist. Abort.".format(choice)+term_mode.NORMAL)
        return 0
    else:
        (keys_list,comment,command) = commands[id]
        if no_confirm:
            if verbose:
                print(term_mode.NORMAL + term_mode.YELLOW + 'Running command: '+ term_mode.NORMAL+'> '  + command + term_mode.NORMAL)
            subprocess.run([command],shell=True)
        else:
            confirmation = input(term_mode.NORMAL + term_mode.YELLOW + 'Run command ? '+ term_mode.NORMAL+'> '  + command +' '+ term_mode.TITLEYELLOW  + '[Y/n]' + term_mode.NORMAL)
            if confirmation:
                if confirmation[0] in 'nN':
                    if verbose:
                        print('Abort')
                else:
                    subprocess.run([command],shell=True)
            else:
                subprocess.run([command],shell=True)
    return 1

def choose_command():
    global has_default_command
    choice = input(term_mode.YELLOW + 'Enter id :'+ term_mode.NORMAL+' '+ term_mode.BLUE+ term_mode.BOLD).strip()
    if not choice:
        if has_default_command:
            choice='default'
        else:
            if verbose:
                print('No choice made.')
    if choice:
        if verbose:
            print(term_mode.NORMAL + 'Choice is : ',choice)
        execute(choice)

def main(argv=None):
    if argv is None:
        argv = sys.argv
    # etc., replacing sys.argv with argv in the getopt() call.
    # parse command line options
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hi:g:dfFovcCws", ["help","file=","global-file=","debug","no-confirm","force-confirm","loop","verbose","no-colors","force-colors""write-ids","standardize"])
    except getopt.GetoptError as err:
        # print help information and exit:
        print(err) # will print something like "option -a not recognized"
        print("for help use --help")
        sys.exit(2)

    # process cmdline-only options (needs to be early for debug flag)
    use_a_global_command_file = process_cmdline_only_options(opts)

    if debug:
        print("argv: ",argv)
        print("opts: ",opts)
        print("args: ",args)

    # process arguments into a string
    key =''
    for w in args:
        key += str(w) + ' '
    key = key.strip()
    if debug:
        print("cmdline key: '" + key + "'")

    # read global config file
    check_then_parse_file(global_config_file,"global config",global_config_file_template)

    # read choosen command file
    if debug:
        print("Using global commands ? : " + str(use_a_global_command_file) )
    if use_a_global_command_file:
        # read global command file
        check_then_parse_file(global_command_file,"global command",command_file_template)
    else:
        # read local command file
        check_then_parse_file(local_command_file,"command",command_file_template)

    # process the rest of command lines options
    # nb : command lines must be processed after command file because it can overwrite options
    process_options(opts)

    if debug:
        print('###### keys_to_id :')
        print(keys_to_id)
        print('###### commands :')
        print(commands)
        print('###### END (commands)')

    try:
        if key:
            # the key was given in the command line
            key_exists = execute(key)
            if not key_exists:
                ans = input(term_mode.YELLOW + 'Show options ? '+ term_mode.NORMAL+' '+ term_mode.TITLEYELLOW  + '[Y/n]' + term_mode.NORMAL)
                if ans and (ans[0] in 'nN'):
                     if verbose:
                        print('Exit')
                     sys.exit(0) # or 1, or whatever
            else:
               sys.exit(0) # or 1, or whatever

        print_command_menu()
        choose_command()
        while loop:
            ans = input(term_mode.YELLOW + 'Continue ? '+ term_mode.NORMAL+' '+ term_mode.TITLEYELLOW  + '[Y/n]' + term_mode.NORMAL)
            if ans and (ans[0] in 'nN'):
                 if verbose:
                    print('Exit')
                 sys.exit(0) # or 1, or whatever
            else:
                print_command_menu()
                choose_command()
    except KeyboardInterrupt:
        sys.exit(0) # or 1, or whatever

if __name__ == "__main__":
    sys.exit(main())
#endif // DO_PY
